/*
 * File: libarray.h
 * Description: All OLED I2C function implementations and data.
 * NOTE: This is an unusual C programming practice. Header files are typically
 * used for function prototypes and declarations, while source files (.c) hold
 * the function definitions. Compiling this file in a project with multiple
 * source files that include it may result in 'multiple definition' errors.
 */

#ifndef __LIBARRAY_H__
#define __LIBARRAY_H__

// --- Pin Definitions ---
sbit SCL = P1^0;  // Serial Clock Line
sbit SDA = P1^1;  // Serial Data Line

// --- OLED Slave Address ---
#define OLED_ADDR 0x78

// --- A complete font table for 5x8 characters (ASCII 32-126) ---
// The 'code' keyword stores this large array in program memory (ROM),
// preventing the 'DATA SEGMENT TOO LARGE' error.
unsigned char code F5x8[][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, // 32 ' ' (Space)
    {0x00, 0x00, 0x5f, 0x00, 0x00}, // 33 '!'
    {0x00, 0x07, 0x00, 0x07, 0x00}, // 34 '"'
    {0x14, 0x7f, 0x14, 0x7f, 0x14}, // 35 '#'
    {0x24, 0x2a, 0x7f, 0x2a, 0x12}, // 36 '$'
    {0x23, 0x13, 0x08, 0x64, 0x62}, // 37 '%'
    {0x36, 0x49, 0x55, 0x22, 0x50}, // 38 '&'
    {0x00, 0x05, 0x03, 0x00, 0x00}, // 39 '''
    {0x00, 0x1c, 0x22, 0x41, 0x00}, // 40 '('
    {0x00, 0x41, 0x22, 0x1c, 0x00}, // 41 ')'
    {0x14, 0x08, 0x3e, 0x08, 0x14}, // 42 '*'
    {0x08, 0x08, 0x3e, 0x08, 0x08}, // 43 '+'
    {0x00, 0x50, 0x30, 0x00, 0x00}, // 44 ','
    {0x08, 0x08, 0x08, 0x08, 0x08}, // 45 '-'
    {0x00, 0x60, 0x60, 0x00, 0x00}, // 46 '.'
    {0x20, 0x10, 0x08, 0x04, 0x02}, // 47 '/'
    {0x3e, 0x51, 0x49, 0x45, 0x3e}, // 48 '0'
    {0x00, 0x42, 0x7f, 0x40, 0x00}, // 49 '1'
    {0x42, 0x61, 0x51, 0x49, 0x46}, // 50 '2'
    {0x21, 0x41, 0x45, 0x4b, 0x31}, // 51 '3'
    {0x18, 0x14, 0x12, 0x7f, 0x10}, // 52 '4'
    {0x27, 0x45, 0x45, 0x45, 0x39}, // 53 '5'
    {0x3c, 0x4a, 0x49, 0x49, 0x30}, // 54 '6'
    {0x01, 0x71, 0x09, 0x05, 0x03}, // 55 '7'
    {0x36, 0x49, 0x49, 0x49, 0x36}, // 56 '8'
    {0x26, 0x49, 0x49, 0x49, 0x3e}, // 57 '9'
    {0x00, 0x36, 0x36, 0x00, 0x00}, // 58 ':'
    {0x00, 0x56, 0x36, 0x00, 0x00}, // 59 ';'
    {0x00, 0x08, 0x14, 0x22, 0x41}, // 60 '<'
    {0x14, 0x14, 0x14, 0x14, 0x14}, // 61 '='
    {0x41, 0x22, 0x14, 0x08, 0x00}, // 62 '>'
    {0x02, 0x01, 0x51, 0x09, 0x06}, // 63 '?'
    {0x32, 0x49, 0x59, 0x49, 0x30}, // 64 '@'
    {0x01, 0x7f, 0x01, 0x01, 0x01}, // 65 'A'
    {0x7f, 0x49, 0x49, 0x49, 0x36}, // 66 'B'
    {0x3e, 0x41, 0x41, 0x41, 0x22}, // 67 'C'
    {0x7f, 0x41, 0x41, 0x22, 0x1c}, // 68 'D'
    {0x7f, 0x49, 0x49, 0x49, 0x41}, // 69 'E'
    {0x7f, 0x09, 0x09, 0x01, 0x01}, // 70 'F'
    {0x3e, 0x41, 0x49, 0x49, 0x7a}, // 71 'G'
    {0x7f, 0x08, 0x08, 0x08, 0x7f}, // 72 'H'
    {0x00, 0x41, 0x7f, 0x41, 0x00}, // 73 'I'
    {0x20, 0x40, 0x41, 0x3f, 0x01}, // 74 'J'
    {0x7f, 0x10, 0x28, 0x44, 0x00}, // 75 'K'
    {0x7f, 0x40, 0x40, 0x40, 0x40}, // 76 'L'
    {0x7f, 0x02, 0x0c, 0x02, 0x7f}, // 77 'M'
    {0x7f, 0x04, 0x08, 0x10, 0x7f}, // 78 'N'
    {0x3e, 0x41, 0x41, 0x41, 0x3e}, // 79 'O'
    {0x7f, 0x09, 0x09, 0x09, 0x06}, // 80 'P'
    {0x3e, 0x41, 0x51, 0x21, 0x5e}, // 81 'Q'
    {0x7f, 0x09, 0x19, 0x29, 0x46}, // 82 'R'
    {0x46, 0x49, 0x49, 0x49, 0x31}, // 83 'S'
    {0x01, 0x01, 0x7f, 0x01, 0x01}, // 84 'T'
    {0x3f, 0x40, 0x40, 0x40, 0x3f}, // 85 'U'
    {0x1f, 0x20, 0x40, 0x20, 0x1f}, // 86 'V'
    {0x3f, 0x40, 0x38, 0x40, 0x3f}, // 87 'W'
    {0x61, 0x14, 0x08, 0x14, 0x61}, // 88 'X'
    {0x07, 0x08, 0x70, 0x08, 0x07}, // 89 'Y'
    {0x41, 0x61, 0x51, 0x49, 0x45}, // 90 'Z'
    {0x00, 0x7f, 0x41, 0x41, 0x00}, // 91 '['
    {0x02, 0x04, 0x08, 0x10, 0x20}, // 92 '\'
    {0x00, 0x41, 0x41, 0x7f, 0x00}, // 93 ']'
    {0x04, 0x02, 0x01, 0x02, 0x04}, // 94 '^'
    {0x40, 0x40, 0x40, 0x40, 0x40}, // 95 '_'
    {0x01, 0x02, 0x04, 0x00, 0x00}, // 96 '`'
    {0x20, 0x54, 0x54, 0x54, 0x78}, // 97 'a'
    {0x7f, 0x48, 0x44, 0x44, 0x38}, // 98 'b'
    {0x38, 0x44, 0x44, 0x44, 0x20}, // 99 'c'
    {0x38, 0x44, 0x44, 0x48, 0x7f}, // 100 'd'
    {0x38, 0x54, 0x54, 0x54, 0x18}, // 101 'e'
    {0x08, 0x7e, 0x09, 0x01, 0x02}, // 102 'f'
    {0x08, 0x14, 0x14, 0x14, 0x1c}, // 103 'g'
    {0x7f, 0x08, 0x04, 0x04, 0x78}, // 104 'h'
    {0x00, 0x44, 0x7d, 0x40, 0x00}, // 105 'i'
    {0x20, 0x40, 0x44, 0x3d, 0x00}, // 106 'j'
    {0x7f, 0x10, 0x28, 0x44, 0x00}, // 107 'k'
    {0x00, 0x7f, 0x40, 0x40, 0x00}, // 108 'l'
    {0x7c, 0x04, 0x18, 0x04, 0x7c}, // 109 'm'
    {0x7c, 0x08, 0x04, 0x04, 0x78}, // 110 'n'
    {0x38, 0x44, 0x44, 0x44, 0x38}, // 111 'o'
    {0x7c, 0x14, 0x14, 0x14, 0x08}, // 112 'p'
    {0x08, 0x14, 0x14, 0x18, 0x7c}, // 113 'q'
    {0x7c, 0x08, 0x04, 0x04, 0x08}, // 114 'r'
    {0x48, 0x54, 0x54, 0x54, 0x20}, // 115 's'
    {0x04, 0x3f, 0x44, 0x40, 0x40}, // 116 't'
    {0x3c, 0x40, 0x40, 0x20, 0x7c}, // 117 'u'
    {0x1c, 0x20, 0x40, 0x20, 0x1c}, // 118 'v'
    {0x3c, 0x40, 0x30, 0x40, 0x3c}, // 119 'w'
    {0x44, 0x28, 0x10, 0x28, 0x44}, // 120 'x'
    {0x0c, 0x50, 0x50, 0x50, 0x3c}, // 121 'y'
    {0x44, 0x64, 0x54, 0x4c, 0x44}, // 122 'z'
    {0x00, 0x08, 0x36, 0x41, 0x00}, // 123 '{'
    {0x00, 0x00, 0x7f, 0x00, 0x00}, // 124 '|'
    {0x00, 0x41, 0x36, 0x08, 0x00}, // 125 '}'
    {0x08, 0x08, 0x2a, 0x1c, 0x08}  // 126 '~'
};


// --- Delay Function (adjust according to your oscillator frequency) ---
void delay_ms(unsigned int ms) {
    unsigned int i, j;
    for (i = 0; i < ms; i++) {
        for (j = 0; j < 1200; j++); // This loop count is for a 12MHz crystal
    }
}

// --- I2C Communication Functions ---
// Start Signal: SDA high -> low while SCL is high.
void I2C_Start(void) {
    SCL = 1;
    SDA = 1;
    _nop_(); _nop_(); // Small delay
    SDA = 0;
    _nop_(); _nop_();
    SCL = 0;
}

// Stop Signal: SDA low -> high while SCL is high.
void I2C_Stop(void) {
    SCL = 0;
    SDA = 0;
    _nop_(); _nop_();
    SCL = 1;
    _nop_(); _nop_();
    SDA = 1;
}

// Acknowledge check
void I2C_Wait_Ack(void) {
    SCL = 1;
    _nop_(); _nop_();
    while (SDA); // Wait for SDA to be low
    SCL = 0;
}

// Send a byte over I2C
void I2C_Send_Byte(unsigned char dat) {
    unsigned char i;
    for (i = 0; i < 8; i++) {
        SDA = (dat & 0x80) ? 1 : 0;
        dat <<= 1;
        _nop_(); _nop_();
        SCL = 1;
        _nop_(); _nop_();
        SCL = 0;
    }
}

// --- OLED Specific Functions ---
// Write a command or data byte to the OLED
void OLED_WR_Byte(unsigned char dat, unsigned char cmd) {
    I2C_Start();
    I2C_Send_Byte(OLED_ADDR);
    I2C_Wait_Ack();
    I2C_Send_Byte(cmd); // 0x00 for command, 0x40 for data
    I2C_Wait_Ack();
    I2C_Send_Byte(dat);
    I2C_Wait_Ack();
    I2C_Stop();
}

// OLED Initialization
void OLED_Init(void) {
    // These commands are specific to the SSD1306 controller
    OLED_WR_Byte(0xAE, 0x00); //--turn off oled panel
    OLED_WR_Byte(0x00, 0x00); //---set low column address
    OLED_WR_Byte(0x10, 0x00); //---set high column address
    OLED_WR_Byte(0x40, 0x00); //--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)
    OLED_WR_Byte(0x81, 0x00); //--set contrast control register
    OLED_WR_Byte(0xCF, 0x00); // Set SEG Output Current Brightness
    OLED_WR_Byte(0xA1, 0x00); //--Set SEG/Column mapping     
    OLED_WR_Byte(0xC8, 0x00); //Set COM/Row Scan Direction   
    OLED_WR_Byte(0xA6, 0x00); //--set normal display
    OLED_WR_Byte(0xA8, 0x00); //--set multiplex ratio(1 to 64)
    OLED_WR_Byte(0x3f, 0x00); //
    OLED_WR_Byte(0xD3, 0x00); //-set display offset	Shift Mapping RAM Display Start Line
    OLED_WR_Byte(0x00, 0x00); //
    OLED_WR_Byte(0xD5, 0x00); //--set display clock divide ratio/oscillator frequency
    OLED_WR_Byte(0x80, 0x00); //
    OLED_WR_Byte(0xD9, 0x00); //--set pre-charge period
    OLED_WR_Byte(0xF1, 0x00); //
    OLED_WR_Byte(0xDA, 0x00); //--set com pins hardware configuration
    OLED_WR_Byte(0x12, 0x00);
    OLED_WR_Byte(0xDB, 0x00); //--set vcomh
    OLED_WR_Byte(0x40, 0x00); //
    OLED_WR_Byte(0x20, 0x00); // Set Memory Addressing Mode
    OLED_WR_Byte(0x02, 0x00); // Page Addressing Mode (0x02)
    OLED_WR_Byte(0x8D, 0x00); //--set Charge Pump enable/disable
    OLED_WR_Byte(0x14, 0x00); //--set Charge Pump enabled
    OLED_WR_Byte(0xA4, 0x00); // Disable Entire Display On (A4/A5)
    OLED_WR_Byte(0xA6, 0x00); // Set Normal Display
    OLED_WR_Byte(0xAF, 0x00); //--turn on oled panel
}

// Clear the entire display
void OLED_CLS(void) {
    unsigned char i, j;
    OLED_WR_Byte(0xB0, 0x00); // Page address (0-7)
    OLED_WR_Byte(0x00, 0x00); // Low column address (0-15)
    OLED_WR_Byte(0x10, 0x00); // High column address (0-7)
    for (i = 0; i < 8; i++) {
        OLED_WR_Byte(0xB0 + i, 0x00); // Set Page Address
        OLED_WR_Byte(0x00, 0x00);     // Set low Column Address
        OLED_WR_Byte(0x10, 0x00);     // Set high Column Address
        for (j = 0; j < 128; j++) {
            OLED_WR_Byte(0x00, 0x40); // Write 0x00 (blank) to each pixel
        }
    }
}

// Set the cursor position to x, y (column, page)
void OLED_Set_Pos(unsigned char x, unsigned char y) {
    OLED_WR_Byte(0xB0 + y, 0x00);     // Set page address
    OLED_WR_Byte(0x00 + (x & 0x0f), 0x00); // Set low column address
    OLED_WR_Byte(0x10 + (x >> 4), 0x00);   // Set high column address
}

// Display a single character
void OLED_ShowChar(unsigned char x, unsigned char y, unsigned char chr) {
    unsigned char c = 0, i = 0;
    c = chr - 32; // Convert character to font table index (ASCII 32 is index 0)
    if (x > 128 - 1) { // Check for horizontal boundary
        x = 0;
        y = y + 1;
    }
    OLED_Set_Pos(x, y);
    for (i = 0; i < 5; i++) {
        OLED_WR_Byte(F5x8[c][i], 0x40); // Send data byte
    }
}

// Display a string
void OLED_ShowString(unsigned char x, unsigned char y, unsigned char *p) {
    while (*p) {
        OLED_ShowChar(x, y, *p);
        x += 6; // Move to the next position (5 pixels for character + 1 for space)
        if (x > 128 - 6) { // Check for line wrap
            x = 0;
            y++;
        }
        p++;
    }
}

// Draw a bitmap (image)
void OLED_Draw_BMP(unsigned char x0, unsigned char y0, unsigned char x1, unsigned char y1, unsigned char BMP[]) {
    unsigned int j = 0;
    unsigned char x, y;

    if (y1 > 8) y1 = 8;
    for (y = y0; y < y1; y++) {
        OLED_Set_Pos(x0, y);
        for (x = x0; x < x1; x++) {
            OLED_WR_Byte(BMP[j++], 0x40);
        }
    }
}
